---
title: TCP三次握手与四次挥手
---

# TCP三次握手与四次挥手 <Badge type="info" text="SHEIN" />

## 网络协议

OSI (Open System Interconnect)规定了七层协议模型，TCP/IP规定了四层模型，七层模型和四层模型的对应关系：

![](https://image-bed.keke.cc/202504291436861.png)

四层模型主要分为：应用层，传输层，网络层，数据链路层。TCP/UDP协议处于传输层。

## TCP通信

TCP通信包括三个步骤：

1. **建立TCP连接通道**

   通过三次握手建立连接

2. **传输数据**

   超时重传、快速重传、流量控制、堵塞控制等等

3. **断开TCP连接通道**

   通过四次挥手断开连接

TCP在传输时会附加自己的TCP包首部。下面是一个TCP头部规范定义：

![](https://image-bed.keke.cc/202504291437256.png)

#### TCP标识位

每个TCP段都有一个自己的目的，通过TCP标识位区分。TCP标志有：

- **`SYN:`** 简写`S`，同步标识位，用于建立会话连接，同步序列号
- **`ACK:`** 简写`.`，确认标识位，对接收的数据包进行确认
- **`FIN:`** 简写`F`，完成标识位，表示已经没有数据要发送了，即将关闭连接
- `PSH:` 简写`P`，推送标识位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队
- `RST:` 简写`R`，重置标识位，用于连接复位、拒绝错误和非法的数据包
- `URG:` 简写`U`，紧急标识位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理

最广泛的标识是`SYN` `ACK` `FIN`，用于建立连接、确认成功、终止连接。

#### TCP序号和确认号

**`seq`**: Sequence number. 32位序号。TCP通信过程中某一个传输方向上的字节流的每个字节的序号。**通过这个来确认发送的数据有序。**

**`ack`**: Acknowledge number. 32位确认号。TCP对上一次`seq`序号做出的确认号，**用来响应TCP报文段**，给收到的TCP报文段的序号`seq`加1。

### TCP三次握手

指建立一个TCP连接时，客户端和服务端总共发送3个报文。

- 客户端 ———SYN=1 seq=X———> 服务端

  客户端将标识位SYN设置成1，随机产生一个序号X。发送完后，客户端进入`SYN_SENT`状态，等待服务器端确认。

- 客户端 <———SYN=1 ACK=1 seq=Y ack=X+1——— 服务端

  服务端收到客户端请求后将SYN和ACK都置为1，ack置为X+1，随机产生一个新的序号值Y。发送完后，服务端进入`SYN_RCVD`状态。

- 客户端 ———ACK=1 ack=Y+1———> 服务端

  客户端收到确认后检查ack是否为X+1，ACK是否为1，如果都是的话，则将ACK置为1，ack置为Y+1，并发回给服务器。服务器检查ACK是否为1，ack是否为Y+1。如果都是的话则连接建立成功。客户端和服务器都进入`ESTABLISHED`状态，此时客户端与服务端可以开始传输数据。

![](https://image-bed.keke.cc/202504291439291.png)

<Collapse>
  <template #title>

**为什么要三次握手？**
<br>
**省流：防止废弃请求异步到达浪费资源（占用服务端连接数）。**

</template>

如果只有两次握手，存在这么一种情况：假如客户端发的第一个请求滞留了，客户端又发了第二个请求。此时第一个请求到达服务端，但第一个请求此时实际上是被废弃的，从服务端发回来后客户端也不会响应。如果只有两次握手，这第一个请求会被服务端一直保存连接，导致服务端资源被浪费。因此需要三次握手。

</Collapse>

### TCP传输过程

1. **超时重传** 超时重传机制用来保证TCP传输的可靠性。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq 号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。
2. **快速重传** 接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重 传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。
3. **流量控制** 这里主要说TCP滑动窗流量控制。TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗可以是提高TCP传输效率的一种机制。
4. **拥塞控制** 滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。

### TCP四次挥手

指TCP需要客户端和服务端总共发送4个报文断开连接。由于TCP连接是全双工的（你能给我发，我能给你发，相互独立），因此每个方向都要单独关闭。挥手可以是客户端发起，也可以是服务端发起，这里我们假设是客户端发起：

- 客户端 ———FIN=1 seq=X———> 服务端

  客户端将FIN置1，生成随机X，向服务端发送断开连接请求。此时客户端状态变成`FIN_WAIT_1`。表示客户端没有数据要发送给服务端了。

- 客户端 <———ACK=1 ack=X+1——— 服务端

  服务端收到FIN包后，返回ACK标识，同时ack返回X+1。服务端进入`CLOSE_WAIT`状态，客户端收到请求后进入`FIN_WAIT_2`状态。服务端告诉客户端，我确认并同意你的关闭请求。

- 客户端 <———FIN=1 seq=Y——— 服务端

  服务端向客户端发送FIN包，请求断开连接。此时服务端状态变为`LAST_ACK`。

- 客户端 ———ACK=1 ack=Y+1———> 服务端

  客户端收到服务端发送的FIN包后回应服务端发送的FIN包，此时客户端进入`TIME_WAIT`状态。当服务端收到客户端的ACK报文后，关闭连接，变为`CLOSED`状态。此时**客户端等待2MSL(报文段最大生存时间)时间后依然没收到回复，则证明服务端已关闭，此时客户端也关闭连接。**

![](https://image-bed.keke.cc/202504291440841.png)

<Collapse>
  <template #title>

**为什么连接时三次握手，断开时四次挥手？**
<br>
**省流：TCP是全双工模式，可能Client（发起方）想断的时候Server（接收方）还有数据没发完**

</template>

建立连接时，当服务端收到SYN请求连接报文后，可以直接返回SYN+ACK报文。SYN报文用来同步，ACK报文用来应答客户端请求。所以只用三次握手。
<br>
断开连接时，由于TCP是全双工模式，当客户端发出FIN报文断开连接时，此时客户端仍能收报文，直到服务端也发送FIN报文段时，连接此时才会中断。

</Collapse>

<Collapse>
  <template #title>

**为什么要等待2MSL？(MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间)**
<br>
**省流：1.保证TCP协议全双工连接可靠关闭 2.保证本次连接的重复数据段从网络中消失**

</template>

1. 如果由于网络原因，服务端没有收到客户端的ACK报文，服务端就会在超时之后重新发送FIN包。如果此时客户端已处于`CLOSED`状态，那么重发的FIN就找不到对应连接了，导致连接错乱。所以要保持`TIME_WAIT`，保证服务端收到ACK包后再关闭连接。
2. 如果客户端发完ACK包后直接进入`CLOSED`，然后再向服务端发起一个新连接，那么新连接和老连接的端口号有可能相同。此时假如前一次连接有些数据包滞留在网络中，在建立新连接后到达客户端，由于新老连接端口和IP一样，TCP会认为这些数据是属于新连接的，新连接的数据包就会混乱。所以需要等待2MSL，保证上次连接所有数据在网络中消失。

</Collapse>
